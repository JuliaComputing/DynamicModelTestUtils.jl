var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ModelTesting","category":"page"},{"location":"#ModelTesting","page":"Home","title":"ModelTesting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ModelTesting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelTesting is intended to facilitate the easy testing and post-facto analysis of ModelingToolkit models. It currently provides two key bits of functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Serialization of MTK solutions into a common format through discretize_solution.\nComparison of solutions to each other and to previously-saved data through compare.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ModelTesting]","category":"page"},{"location":"#ModelTesting.DefaultComparison","page":"Home","title":"ModelTesting.DefaultComparison","text":"DefaultComparison is a convenience default comparison method for solutions and reference data. \n\nBy default it's instantiated with lâˆž, l1, l2, RMS, and final l1 comparsons. More can be added by passing a dict of name=>comparison function pairs into field_cmp, with the signature (delta, dtdelta, t) -> [vector difference]. The arguments of these comparison functions are delta for the raw difference beteween the value, `dtdelta` for the  product of dt and delta (if you want to approximate the integral of the error), and the timestamps at which the data was produced. The arguments consist of a vector per compared field.\n\n\n\n\n\n","category":"type"},{"location":"#ModelTesting.DefaultComparison-NTuple{6, Any}","page":"Home","title":"ModelTesting.DefaultComparison","text":"(d::DefaultComparison)(c, names, b, t, n, r)\n\nDefault comparison implementation. Returns a dataframe that describes the result of running each comparison operation on the given data.\n\n#Arguments\n\nc: The symbolic container from which the values we're comparing came\nnames: The names to output for the fields we're comparing (not always the same as the names of the fields being compared)\nb: The symbolic variables that are being compared\nt: The timestamps at which the comparison is taking place \nn: The new values being compared\nr: The reference values to compare against\n\n\n\n\n\n","category":"method"},{"location":"#ModelTesting.compare","page":"Home","title":"ModelTesting.compare","text":"compare(\n    new_sol::SciMLBase.AbstractTimeseriesSolution,\n    reference::DataFrame,\n    cmp=DefaultComparison(); to_name=string, warn_observed=true)\n\ncompare compares the results of new_sol to a result in reference, which may come from either experiment or a previous model execution. The format of reference is that produced by discretize_solution:\n\nA column named \"timestamp\" that indicates the time the measurement was taken (referenced to the same timebase as the solution provided)\nColumns with names matching the names in the completed system new_sol (fully qualified)\n\nIf new_sol is dense then the discretization nodes don't need to line up with the reference and the interpolant will be used instead. If it is not dense then the user must ensure that the saved states in are at the same times as the \"timestamp\"s are in the reference data.\n\ncompare will use the comparison method specified by cmp to compare the two solutions; by default it uses the DefaultComparison (which offers l1, l2, and rms comparisons per observed value), but you can pass your own. Look at DefaultComparison for more details on how.\n\nThe two optional named parameters are to_name (which is used to convert the symbolic variables in new_sol into valid column names for  the dataframe) and warn_observed which controls whether compare complains about comparing observed values to non-observed values. We suggest leaving warn_observed on for regression testing (it'll give you a note when MTK changes the simplifcation of the system).\n\n\n\n\n\n","category":"function"},{"location":"#ModelTesting.compare-2","page":"Home","title":"ModelTesting.compare","text":"compare(\n    new_sol::SciMLBase.AbstractTimeseriesSolution,\n    reference::DataFrame,\n    over::Vector{<:Union{Pair{<:Any, String}, Pair{<:Any, Pair{String, String}}}}\n    cmp=DefaultComparison(); warn_observed=true)\n\nLower level version of compare that lets you specify the mapping from values in new_sol (specified as either variable => name or variable => (inputname, outputname) pairs) to the column names in reference. The tuple-result version lets you specify what the column names are when passed to the comparison method. Since the mapping is explicit this version does not take to_name, but it still does take warn_observed. See the implicit-comparison version of compare for more information.\n\n\n\n\n\n","category":"function"},{"location":"#ModelTesting.discretize_solution-Tuple{SciMLBase.AbstractTimeseriesSolution, SciMLBase.AbstractTimeseriesSolution}","page":"Home","title":"ModelTesting.discretize_solution","text":"discretize_solution(solution::SciMLBase.AbstractTimeseriesSolution[, time_ref::SciMLBase.AbstractTimeseriesSolution]; measured=nothing, all_observed=false)\n\ndiscretize_solution takes a solution and an optional time reference and converts it into a dataframe. This dataframe will contain either:\n\nThe variables (unknowns or observeds) named in measured, if provided.\nThe variables marked as measured if all_observed is false and measured is nothing.\nAll variables in the system if all_observed is true and measured is nothing.\n\nThe dataframe will contain a column called timestamp for each of the discretization times and a column for each observed value.\n\nIf no time reference is provided then the timebase used to discretize solution will be used instead. \n\n\n\n\n\n","category":"method"},{"location":"#ModelTesting.test_instantaneous-Tuple{ModelingToolkit.AbstractSystem, Any, Array}","page":"Home","title":"ModelTesting.test_instantaneous","text":"test_instantaneous(sys::ModelingToolkit.AbstractSystem,\n    ic,\n    checks::Union{Num, Array};\n    t = nothing)\n\ntest_instantaneous is a helper wrapper around constructing and executing an ODEProblem at a specific condition. It's intended for use in basic sanity checking of MTK models, for example to ensure that the derivative at a given condition has the correct sign. It should be passed the system, the initial condition dictionary to be given to the ODEProblem constructor (including parameters), and a list of observable values from the system to extract from the ODEProblem. If checks is a single Num then the result will be that observed value; otherwise it will return an array in the same order as the provided checks.\n\n\n\n\n\n","category":"method"}]
}
